<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>let和const</title>
</head>
<body>
  
</body>
<script>
  //1.let命令
  //基本用法--ES6新增了let命令,用来声明变量.用法类似与var,但是所声明的变量,只在let命令所在的代码块有效
  {
    let a = 10;
    var b =1;
  }  
  console.log(b) //1
  //console.log(a) //Uncaught ReferenceError: a is not defined
  //上述报错原因 let声明的变量只在它所在的代码块有效

  //for循环的计数器,就很适合使用let命令
  for(let i=0;i<10;i++){

  }
  //console.log(i) //// ReferenceError: i is not defined

  var a  = [];
  for(var i=0;i<10;i++){
    a[i] = function(){
      console.log(i)
    }
  }
  a[6]() //10  循环结束的时候I已经循环到10,输出10

  for(let i =0;i<3;i++){
    let i = 'abc';
    console.log(i)
  }
  //上边代码中变量i是Let生命的,当前的i只在本轮循环有效,所以美哦一次循环的i都是一个新的变量,所以最后输出的是6
  //如果每一轮的循环变量都是新生命,那它怎么知道上一轮循环的值,从而计算出本轮的值?这是因为js引擎内部会记住上一轮循环的值 初始化本轮的变量i时,就在上一轮循环的基础上进行计算
  //另外.for循环还有一个特别支出 就是设置循环变量的那部分是一个父作用域,而循环体内部是一个子作用域

  //不存在变量提升
  //var命令会发生''变量提升现象 即变量可以在声明之前使用,值为undefined'
  console.log(foo); //undefined
  var foo = 2;

  console.log(bar);//报错 ReferenceError:
  let bar =2;

  //暂时性死区
  //es6明确规定,如果区块中存在let和const命令,这个区块对这些命令生命的变量,从一开始就形成封闭作用域,凡在声明之前使用这些变量,就会报错

  if(true) {
    tmp = 'abc';
    console.log(tmp); //ReferenceError
    let tmp
  }
  //不允许重复生命
  //let不允许在相同作用域内,重复生明同一个变量

  //块级作用域---为什么要需要块级作用域呢?
  //ES5只有全局作用域和函数作用域,没有块级作用域,这带来很多不合理的场景

  //1.第一种场景,内层变量可能会覆盖外层变量
  



</script>
</html>